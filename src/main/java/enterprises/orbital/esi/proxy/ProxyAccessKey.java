package enterprises.orbital.esi.proxy;

import java.io.IOException;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.util.List;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Index;
import javax.persistence.JoinColumn;
import javax.persistence.Lob;
import javax.persistence.ManyToOne;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.NoResultException;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;
import javax.persistence.Transient;
import javax.persistence.TypedQuery;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;

import enterprises.orbital.base.OrbitalProperties;
import enterprises.orbital.base.Stamper;
import enterprises.orbital.db.ConnectionFactory.RunInTransaction;
import enterprises.orbital.db.ConnectionFactory.RunInVoidTransaction;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

/**
 * An key/hash pair for accessing ESI via the proxy. This object records:
 * 
 * <ul>
 * <li>The latest access token for an EVE user.
 * <li>The expiry time of the access token.
 * <li>The latest refresh token for an EVE user.
 * <li>The list of scopes associated with this key when it was created.
 * <li>The expiry date for this key.
 * <li>The unique ID of this key.
 * <li>The random seed used to generate the hash for this key.
 * </ul>
 * 
 * We use this object to translate a key/hash pair to an access token as follows:
 * 
 * <ol>
 * <li>Caller (via REST) passes a key/hash pair as part of the query string of the requested operation.
 * <li>Proxy maps the key to an instance of this class and compares the hash passed on the call with the hash generated by this key.
 * <li>If the hash does not match, the request is rejected with an error.
 * <li>If the key is expired, then the request is rejected with an error.
 * <li>If the hash matches, the key/hash query parameters are removed and an authorization header is added to the request using the access token stored in this
 * object.
 * </ol>
 * 
 */
@Entity
@Table(
    name = "proxy_access_keys",
    indexes = {
        @Index(
            name = "userIndex",
            columnList = "uid",
            unique = false),
        @Index(
            name = "keyIndex",
            columnList = "kid",
            unique = true)
    })
@NamedQueries({
    @NamedQuery(
        name = "ProxyAccessKey.findByID",
        query = "SELECT c FROM ProxyAccessKey c where c.kid = :kid"),
    @NamedQuery(
        name = "ProxyAccessKey.findAllByUser",
        query = "SELECT c FROM ProxyAccessKey c where c.user = :user")
})
@ApiModel(
    description = "Proxy access key")
@JsonIgnoreProperties({
    "randomSeed", "user", "accessToken", "refreshToken"
})
public class ProxyAccessKey {
  protected static final Logger            log      = Logger.getLogger(ProxyAccessKey.class.getName());

  protected static ThreadLocal<ByteBuffer> assembly = new ThreadLocal<ByteBuffer>() {
                                                      @Override
                                                      protected ByteBuffer initialValue() {
                                                        // Since we use the user's account name in the hash we need to
                                                        // allocate to the largest possible size allowed for a data store
                                                        // string (which is currently 500 bytes).
                                                        return ByteBuffer.allocate(550);
                                                      }
                                                    };

  public static class BigIntegerSerializer extends JsonSerializer<BigInteger> {
    @Override
    public void serialize(
                          BigInteger value,
                          JsonGenerator jgen,
                          SerializerProvider provider)
      throws IOException, JsonProcessingException {
      jgen.writeString(value.toString());
    }
  };

  // Unique key ID
  @Id
  @GeneratedValue(
      strategy = GenerationType.SEQUENCE,
      generator = "proxy_seq")
  @SequenceGenerator(
      name = "proxy_seq",
      initialValue = 100000,
      allocationSize = 10,
      sequenceName = "account_sequence")
  @ApiModelProperty(
      value = "Unique key ID")
  @JsonProperty("kid")
  private long             kid;
  // User which owns this key
  @ManyToOne
  @JoinColumn(
      name = "uid",
      referencedColumnName = "uid")
  private ProxyUserAccount user;
  // Fixed at the time this key is created, we use this field to randomize the hash.
  private long             randomSeed;
  // -1 for a key which never expires, otherwise this is the time in UTC when the given key will expire.
  @ApiModelProperty(
      value = "-1 if this key never expires, otherwise the date (milliseconds UTC) when this key expires")
  @JsonProperty("expiry")
  private long             expiry = -1;
  // Space delimited list of scopes attached to this key when it was created
  @ApiModelProperty(
      value = "Space separated list of scopes that were authenticated when this key was created")
  @JsonProperty("scopes")
  @Lob
  @Column(
      length = 102400)
  private String           scopes;
  // The character name associated with this key. This was the character used during OAuth authentication.
  @ApiModelProperty(
      value = "Name of character used for authentication when this key was created")
  @JsonProperty("characterName")
  private String           characterName;
  // Latest access token
  private String           accessToken;
  // Expiry date (millis UTC) of access token
  @ApiModelProperty(
      value = "Date (milliseconds UTC) when access token associated with this key will expire")
  @JsonProperty("accessTokenExpiry")
  private long             accessTokenExpiry;
  // Latest refresh token
  private String           refreshToken;
  // Hash computed when needed for communication to owning user.
  @Transient
  @ApiModelProperty(
      value = "Access credential")
  @JsonProperty("credential")
  private String           credential;
  // Server type authenticated against. Must be one of 'latest', 'legacy' or 'dev'
  @ApiModelProperty(
      value = "Server type (one of 'latest', 'legacy', or 'dev'")
  @JsonProperty("serverType")
  private String           serverType;

  public String getCharacterName() {
    return characterName;
  }

  public void setCharacterName(
                               String characterName) {
    this.characterName = characterName;
  }

  public long getKid() {
    return kid;
  }

  public ProxyUserAccount getUser() {
    return user;
  }

  public String getScopes() {
    return scopes;
  }

  public long getRandomSeed() {
    return randomSeed;
  }

  public void setRandomSeed(
                            long randomSeed) {
    this.randomSeed = randomSeed;
  }

  public long getExpiry() {
    return expiry;
  }

  public void setExpiry(
                        long expiry) {
    this.expiry = expiry;
  }

  public String getCredential() {
    return credential;
  }

  public void setCredential(
                            String credential) {
    this.credential = credential;
  }

  public String getAccessToken() {
    return accessToken;
  }

  public void setAccessToken(
                             String accessToken) {
    this.accessToken = accessToken;
  }

  public long getAccessTokenExpiry() {
    return accessTokenExpiry;
  }

  public void setAccessTokenExpiry(
                                   long accessTokenExpiry) {
    this.accessTokenExpiry = accessTokenExpiry;
  }

  public String getRefreshToken() {
    return refreshToken;
  }

  public void setRefreshToken(
                              String refreshToken) {
    this.refreshToken = refreshToken;
  }

  public String getServerType() {
    return serverType;
  }

  public void setServerType(
                            String serverType) {
    this.serverType = serverType;
  }

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((characterName == null) ? 0 : characterName.hashCode());
    result = prime * result + (int) (kid ^ (kid >>> 32));
    result = prime * result + (int) (randomSeed ^ (randomSeed >>> 32));
    result = prime * result + ((scopes == null) ? 0 : scopes.hashCode());
    result = prime * result + ((serverType == null) ? 0 : serverType.hashCode());
    result = prime * result + ((user == null) ? 0 : user.hashCode());
    return result;
  }

  @Override
  public boolean equals(
                        Object obj) {
    if (this == obj) return true;
    if (obj == null) return false;
    if (getClass() != obj.getClass()) return false;
    ProxyAccessKey other = (ProxyAccessKey) obj;
    if (characterName == null) {
      if (other.characterName != null) return false;
    } else if (!characterName.equals(other.characterName)) return false;
    if (kid != other.kid) return false;
    if (randomSeed != other.randomSeed) return false;
    if (scopes == null) {
      if (other.scopes != null) return false;
    } else if (!scopes.equals(other.scopes)) return false;
    if (serverType == null) {
      if (other.serverType != null) return false;
    } else if (!serverType.equals(other.serverType)) return false;
    if (user == null) {
      if (other.user != null) return false;
    } else if (!user.equals(other.user)) return false;
    return true;
  }

  @Override
  public String toString() {
    return "ProxyAccessKey [kid=" + kid + ", user=" + user + ", randomSeed=" + randomSeed + ", expiry=" + expiry + ", scopes=" + scopes + ", characterName="
        + characterName + ", accessToken=" + accessToken + ", accessTokenExpiry=" + accessTokenExpiry + ", refreshToken=" + refreshToken + ", credential="
        + credential + ", serverType=" + serverType + "]";
  }

  public static ProxyAccessKey createKey(
                                         final ProxyUserAccount user,
                                         final long expiry,
                                         final String serverType,
                                         final String scopes,
                                         final String characterName) {
    ProxyAccessKey newKey = null;
    try {
      newKey = ProxyUserAccountProvider.getFactory().runTransaction(new RunInTransaction<ProxyAccessKey>() {
        @Override
        public ProxyAccessKey run() throws Exception {
          long seed = new Random(OrbitalProperties.getCurrentTime()).nextLong();
          ProxyAccessKey result = new ProxyAccessKey();
          result.user = user;
          result.serverType = serverType;
          result.expiry = expiry;
          result.scopes = scopes;
          result.characterName = characterName;
          result.randomSeed = seed;
          return ProxyUserAccountProvider.getFactory().getEntityManager().merge(result);
        }
      });
    } catch (Exception e) {
      log.log(Level.SEVERE, "query error", e);
    }
    return newKey;
  }

  public static ProxyAccessKey getKeyByID(
                                          final long kid) {
    try {
      return ProxyUserAccountProvider.getFactory().runTransaction(new RunInTransaction<ProxyAccessKey>() {
        @Override
        public ProxyAccessKey run() throws Exception {
          TypedQuery<ProxyAccessKey> getter = ProxyUserAccountProvider.getFactory().getEntityManager().createNamedQuery("ProxyAccessKey.findByID",
                                                                                                                        ProxyAccessKey.class);
          getter.setParameter("kid", kid);
          try {
            return getter.getSingleResult();
          } catch (NoResultException e) {
            return null;
          }
        }
      });
    } catch (Exception e) {
      log.log(Level.SEVERE, "query error", e);
    }
    return null;
  }

  public static List<ProxyAccessKey> getAllKeys(
                                                final ProxyUserAccount owner) {
    try {
      return ProxyUserAccountProvider.getFactory().runTransaction(new RunInTransaction<List<ProxyAccessKey>>() {
        @Override
        public List<ProxyAccessKey> run() throws Exception {
          TypedQuery<ProxyAccessKey> getter = ProxyUserAccountProvider.getFactory().getEntityManager().createNamedQuery("ProxyAccessKey.findAllByUser",
                                                                                                                        ProxyAccessKey.class);
          getter.setParameter("user", owner);
          return getter.getResultList();
        }
      });
    } catch (Exception e) {
      log.log(Level.SEVERE, "query error", e);
    }
    return null;
  }

  public static boolean deleteKey(
                                  final ProxyUserAccount owner,
                                  final long kid) {
    try {
      ProxyUserAccountProvider.getFactory().runTransaction(new RunInVoidTransaction() {
        @Override
        public void run() throws Exception {
          ProxyAccessKey key = getKeyByID(kid);
          if (key != null && key.getUser().equals(owner)) ProxyUserAccountProvider.getFactory().getEntityManager().remove(key);
        }
      });
      return true;
    } catch (Exception e) {
      log.log(Level.SEVERE, "query error", e);
    }
    return false;
  }

  public static void updateKey(
                               final ProxyUserAccount owner,
                               final long kid,
                               final long expiry) {
    try {
      ProxyUserAccountProvider.getFactory().runTransaction(new RunInVoidTransaction() {
        @Override
        public void run() throws Exception {
          ProxyAccessKey key = getKeyByID(kid);
          if (key == null || !key.getUser().equals(owner)) return;
          key.setExpiry(expiry);
          ProxyUserAccountProvider.getFactory().getEntityManager().merge(key);
        }
      });
    } catch (Exception e) {
      log.log(Level.SEVERE, "query error", e);
    }
  }

  public static ProxyAccessKey update(
                                      final ProxyAccessKey key) {
    try {
      return ProxyUserAccountProvider.getFactory().runTransaction(new RunInTransaction<ProxyAccessKey>() {
        @Override
        public ProxyAccessKey run() throws Exception {
          return ProxyUserAccountProvider.getFactory().getEntityManager().merge(key);
        }
      });
    } catch (Exception e) {
      log.log(Level.SEVERE, "query error", e);
      return null;
    }
  }

  public void generateCredential() {
    setCredential(generateHash(this));
  }

  public static String generateHash(
                                    ProxyAccessKey ref) {
    ByteBuffer assemble = assembly.get();
    assemble.clear();

    // Assemble contents. The hash consists of:
    //
    // - unique key ID
    // - unique user ID
    // - random seed
    // - character name
    //
    // All of the values are fixed at creation time, thus a hash value never changes.
    assemble.putLong(ref.getKid());
    assemble.putLong(ref.getUser().getID());
    assemble.putLong(ref.getRandomSeed());
    assemble.put(ref.getCharacterName().getBytes());
    assemble.limit(assemble.position());
    assemble.rewind();

    return Stamper.digest(assemble);
  }

  public static ProxyAccessKey checkHash(
                                         long keyID,
                                         String submittedHash)
    throws NoSuchKeyException {
    ProxyAccessKey accessKey = getKeyByID(keyID);

    if (accessKey == null) throw new NoSuchKeyException("No access key found with ID: " + String.valueOf(keyID));

    return generateHash(accessKey).equals(submittedHash) ? accessKey : null;
  }

}
